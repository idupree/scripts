# SSH reverse tunnel to a server to expose a local TCP port
# on the public internet.
#
# Replace all CONFIG_* text in this file with your own
# values in order to actually use it.
#
# You have to have a server you can SSH to.  Its
# firewall rules (if any) have to expose at least one
# otherwise-unused port unless you only wanted to access
# your local port from that particular server's localhost.
# (If the latter, you can delete the colon that immediately
# follows -R in order to limit it to the server's localhost.)
# Small virtual servers are fine and cost about $5/month as of 2015.
#
# Using a friend's server is fine if they are okay with it.
# Your friend can allow you to create tunnels while preventing
# you from running commands by prefixing your key's .ssh/authorized_keys
# line with:
#   command="/bin/echo this authorized key is only for port forwarding"
# followed by a space and then the usual "ssh-rsa AAAA......."
# Unfortunately with reverse tunnels, your friend can't limit
# *which* port you open in this manner (permitopen= only
# works in conjunction with `ssh -L`), but your friend can
# add no-pty,no-X11-forwarding to the comma-separated authorized_keys
# line's prefix to restrict a couple more unnecessary features:
#   command="/bin/echo this authorized key is only for port forwarding",no-pty,no-X11-forwarding
#
# As an example purpose, you could expose SSH port 22 on your
# Raspberry Pi so you can connect to it from another city.
# Make sure to turn off SSH PasswordAuthentication before exposing
# your SSH port to the world, and use only RSA keys with 2048+ bits.
#
# Be aware this script is against some corporate policies so
# only do it on a corporate LAN if you think it's okay.
# Residential ISPs usually have terms of service that
# nominally ban servers but don't actually mind unless
# you are regularly hogging the uplink bandwidth.
#
# I've seen at least one ISP that somehow prevents connections
# from working if they start from your home and then return
# back into your home from the public internet.  This can
# mean your reverse tunnel might work anywhere *but* the
# network you set it up on.
#
# I've found this script fairly reliable but something's went
# wrong every few months so:
#  - not good for use in production
#  - think about whether someone will be physically there
#    to fix it if something goes wrong
#
# Some of this config is inspired by
# https://wiki.archlinux.org/index.php/Secure_Shell#Run_Autossh_automatically_at_boot_via_systemd
#
#
# Design decision details:
#
# After=network.target is unreliable because there are
# several steps to getting a net connection -- getting on the LAN,
# setting up DNS, etc. -- but it won't hurt, and may help autossh
# be less confused (not sure if AUTOSSH_GATETIME=0 makes this line
# completely moot or only somewhat moot).  See
# http://www.freedesktop.org/wiki/Software/systemd/NetworkTarget/
# Also, even with After=network.target and AUTOSSH_GATETIME=0,
# I think I've seen occasional failure when using a DNS name
# for the remote server so I err towards using the server's IP if
# it has a stable IP.
#
# -oStrictHostKeyChecking=no so that you don't have to figure out how to
# accept a new server's fingerprint when you set this script up. If the
# server's fingerprint changes, you'll still have to
# deal with ~/.ssh/known_hosts (you'll know what went wrong by checking
# `sudo systemctl status name-of-this-service-file.service`).
#
# -oServerAliveInterval=60 -oServerAliveCountMax=3 makes sure that if
# the client-server connection stops working, autossh will notice within
# three minutes and be able to try restarting ssh. -M 0 disables autossh's
# inferior built-in method of doing this.  The server will probably notice
# the disconnection too because its TCPKeepAlive defaults to yes, allowing
# the server to release the open listening port it had made for the
# defunct connection.
#
# -oExitOnForwardFailure=yes makes autossh able to notice when the SSH
# connection worked but the forwarding failed, so that it can try again
# (for example to wait for the server to time-out an old stale
#  port-forwarding connection).

[Unit]
Description=Creates a public reverse tunnel from a server to a port of this computer.
After=network.target

[Service]
Type=simple
User=CONFIG_LOCAL_SSH_CLIENT_USER
Environment="AUTOSSH_GATETIME=0"
ExecStart=/bin/sh -c 'exec autossh -M 0 -oStrictHostKeyChecking=no -oServerAliveInterval=60 -oServerAliveCountMax=3 -oExitOnForwardFailure=yes -N -R :CONFIG_REMOTE_PORT_TO_OPEN:localhost:CONFIG_LOCAL_PORT_TO_EXPOSE CONFIG_REMOTE_SERVER_USER@CONFIG_REMOTE_SERVER_IP'

[Install]
WantedBy=multi-user.target

